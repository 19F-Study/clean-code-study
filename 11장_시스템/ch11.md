# 클린코드, 11장 시스템 스터디 자료

### 도시를 세운다면?
- 도시가 돌아가는 이유는 적절한 추상화와 모듈화 때문이다. 도시의 큰 그림을 이해하지 못 할지라도 개인과 개인이 관리하는 '구성요소'는 효율적으로 돌아간다.
- 소프트웨어 팀도 도시처럼 구성하지만 막상 팀이 제작하는 시스템은 비슷한 수준으로 관심사를 분리하거나 추상화를 이뤄내지 못 한다. 이 장에서는 시스템 수준에서 깨끗함을 유지하는 방법을 알아본다.

<br>

### 시스템 제작과 시스템 사용을 분리하라
- 제작(Construction)과 사용(Use)
    - 건설에 비유했을 때 제작이란 건물을 짓는 과정에 해당한다. 건물을 짓는 과정에선 현장에 작업복을 착용한 사람들, 기중기와 승강기 등이 보인다. 그러나 이런 것들은 제작이 끝나면 사라진다. 사용은 건물이 완공된 이후의 모습이다. 건물이 호텔이라면 사용 시점에 건물엔 기중기와 승강기는 없고 깔끔한 유리벽, 예쁜 색상의 벽으로 꾸며져 있을 것이다. 그리고 건물에 보이는 사람들도 다른 사람들일 것이다.
    - 소프트웨어 시스템에서 제작이란 어플리케이션 객체를 제작하고 의존성을 서로 *연결*하는 준비 과정을 말하고 사용이란 그 이후에 이어지는 런타임 로직을 말한다.

- 관심사(Concern), 관심사 분리
    -  관심사가 적절히 분리되지 않은 예, Lazy Evaluation
        - Lazy Evaluation은 여러가지 장점이 있다. 그러나 단순히 아래와 같이 구현한 것은 준비 과정 코드와 런타임 로직이 마구 뒤섞인 예이다.
        ```java
            public Service getService() {
                if (service == null)
                    service = new MyServiceImpl(...); // 모든 상황에 적합한 기본값일까?
                return service;
            }
        ```
        - 위와 같이 구현된 코드는 여러가지 문제가 있다. 
            - 런타임 로직에서 MyServiceImpl을 사용하지 않는다고 하더라도 반드시 의존성을 포함할 것을 강제한다.
            - 테스트 시 적절한 테스트 전용 객체를 service 변수에 미리 할당해야 한다.
            - 테스트 시 객체 생성 로직에 따라 테스트 해야 하는 경로의 수가 늘어난다.
            - MyServiceImpl이 모든 상황에 적합한 객체인지 알 수 없다.
            
    - 시스템 생성과 시스템 사용을 분리하는 방법 1, Main 분리
        - main 함수에서 시스템에 필요한 객체를 생성한 후 이를 어플리케이션에 넘기는 방법이다. 어플리케이션은 main이나 객체가 생성되는 과정을 전혀 모르고 그저 main으로 부터 넘겨받은 객체를 사용할 뿐이다. 

    - 시스템 생성과 시스템 사용을 분리하는 방법 2, 팩토리
        - ABSTRACT FACTORY 패턴
            - https://en.wikipedia.org/wiki/Abstract_factory_pattern
            - 별도 자료 참고

    - 시스템 생성과 시스템 사용을 분리하는 방법 3, 의존성 주입
        - 의존성 주입(Dependency Injection)은 제어 역전 기법을 의존성 관리에 적용한 메커니즘이다. 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다. 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 된다.    
        - 대표적인 예로 초기 설정이 있는데 초기 설정은 시스템 전체에서 필요하므로 '책임질' 메커니즘으로 'main'루틴이나 특수 컨테이너를 사용한다.
        - 진정한 의존성 주입은 클래스가 의존성을 해결하려 시도하지 않는다. 클래스는 완전히 수동적이고 setter 메서드나 생성자 인수를 제공한다. DI 컨테이너가 필요한 객체의 인스턴스를 만들고 setter 메서드나 생성자 인수를 통해 의존성을 설정한다.
            - 스프링 프레임워크의 예
        - 참고: 의존 관계 역전의 원칙, https://vandbt.tistory.com/42
        - 참고: 제어의 역전이란 무엇인가?, https://vandbt.tistory.com/43 

<br>

### 확장 
> '처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확정하면 된다. (199p)

- 소프트웨어 시스템은 물리적인 시스템과는 달리 관심사를 적질히 분리해 관심한다면 시스템 수준에서도 점진적으로 발전할 수 있다.
    - 관심사를 적절히 분리하지 못한 예, EJB1, EJB2
        - EJB1, EJB2에서는 비지니스 논리가 EJB2 어플리케이션 '컨테이너'에 강하게 결합되었다. 클래스를 생성할 때 컨테이너에서 파생해야 하고 컨테이너가 요구하는 다양한 생명주기 메서드를 제공해야 한다. 이렇게 비지니스 논리가 결합됨에 따라 단위 테스트를 작성하기 어렵고 프레임워크 밖에서 코드를 재사용하기가 사실상 불가능하다.
        - 그러나 일부 영역에선 관심사를 거의 완벽하게 분리하기도 한다. 트랜잭션, 보안, 일부 영속적인 영역은 소스코드가 아니라 XML 배포 기술자에서 정의한다. 이런 것들을 처리하는 방법은 관점 지향 프로그래밍(Aspect-Oriented Programming, AOP)을 예견했다고 보인다. 관점(Aspect)란 모듈 구성 개념은 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 연동하는 방식을 일관성있게 바꿔야 한다"라고 명시한다. 

- 자바에서 사용하는 관점 혹은 관점과 유사한 매커니즘 1, 자바 프록시
    - 자바 프록시는 개별 객체나 클래스에서의 메서드 호출을 프록시로 감싸는 경우이다. 비지니스 논리를 구현한 POJO(Plain Old Java Object)를 구현한 뒤 InvocationHandler를 통해 이 POJO에서의 메서드 실행을 감싸준다.
    - 자바 프록시는 단순한 예제에서는 적합하지만 코드가 많아지고 복잡해진다. 즉 깔끔한 코드를 작성하기 어려워진다. 또한 진정한 AOP 해법에 필요한 실행 '지점'을 명시하는 메커니즘도 제공하지 않는다.

- 자바에서 사용하는 관점 혹은 관점과 유사한 매커니즘 2, 순수 자바 AOP 프레임워크
    - 스프링 프레임워크의 예
    - 스프링은 비지니스 논리를 POJO로 구현한다. POJO는 순수하게 도메인에 초점을 맞춘다. POJO는 엔터프라이즈 프레임워크 또는 다른 도메인에 의존하지 않는다.
    - 개발자는 설정 파일이나 API를 이용해 어플리케이션 기반 구조와 횡단 관심사(영속서, 트랜잭션, 보안, 캐시, 장애조치 등)을 구현한다. 

- 자바에서 사용하는 관점 혹은 관점과 유사한 매커니즘 3, AspectJ
    - 관심사를 관점으로 분리하는 가장 강력한 도구이다. 스프링 AOP와 JBoss AOP가 제공하지 못 하는 부분을 제공한다. 그러나 사용하기 위해선 새 언어 문법과 사용법을 익혀야 하는 단점이 있다.

- 테스트 주도 시스템 아키텍처 구축 
    - 관점으로 관심사를 잘 분리할 수 있다면, 즉 어플리케이션 도메인 논리를 POJO로 작성할 수 있다면 테스트 주도 시스템 아키텍처 구축이 가능해진다. 이는 시스템의 변경이 용이하다는 말로 구현을 시작하기 전에 앞으로 모든 사항을 설계하는 것을 추구할 필요가 없다는 말이다.

- 의사 결정을 최적화하라
    - 관심사를 모듈로 분리한다면 가장 적합한 사람에게 책임을 맡길 수 있다. 또한 최대한 정보를 모아 의사 결정을 할 수도 있어 최적의 결정을 내리기 쉬워진다.

- 명백한 가치가 있을 때 표준을 현명하게 사용하라
    - 표준은 분명한 목적이 있어야 한다. 재사용의 용이성, 사람을 구하기 쉬운 점, 컴포넌트를 엮기 쉬운 점 등이 표준을 사용하는 목적이다. 단지 표준이라는 이유 만으로 표준을 사용하면 안된다.

- 시스템은 도메인 특화 언어가 필요하다
    - Spring Framework 5 Kotlin APIs, the functional way
        - Link:  https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way

### 기타
- ABSTRACT FACTORY PATTERN
- What is POJO?
    -  Link: https://spring.io/understanding/POJO

> 출처  
Robert C. Martin. (2013). 클린 코드 (박재호, 이해영 옮김). 인사이트