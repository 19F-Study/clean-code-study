# 14장 점진적인 개선 
**점진적으로 개선하다**  
> 프로그램을 망치는 가장 좋은 방법은 "개선이라는 이름 아래" 구조를 크게 뒤집는 행위  
왜 ?   
개선 전과 똑같이 프로그램을 돌리기가 아주 어렵기 때문

### TDD
TDD는 언제 어느 때라도 시스템이 돌아가야 한다는 원칙을 따른다. 따라서 TDD는 시스템을 망가뜨리는 변경을 허용하지 않는다.

> 변경을 가한 후에도 시스템이 변경 전과 똑같이 돌아가야 한다. 이를 확인하기 위해서 무엇을 해야할까?

**자동화된 테스트 슈트가 필요하다**  

- 한번에 하나씩 고치면서 테스트를 계속 돌린다
- 테스트 케이스가 하나라도 실패하면 다음 변경으로 넘어가기 전에 오류를 수정한다
- 위의 과정을 반복하며 시스템의 정상 동작을 유지하며 변경을 가한다
- ..........

> 위의 과정을 통해 기존의 코드를 열심히 고쳤지만 결과는???   
구조만 조금 나아졌을뿐..........

#### 실망스럽다!

1. 첫머리에 나오는 변수는 그대로 남아있다
2. 보기 싫은 코드도 그대로 남아있다
3. 모든 set 함수도 그대로 있다
4. 오류 처리 코드도.......    

즉, 여전히 해야 할 일들이 매우 많이 남아 있다는 것을 알 수 있다

### 리팩터링

리팩터링을 하다보면 코드를 넣었다 뺐다 하는 사례가 아주 흔하다

#### 왜?
단계적으로 조금씩 변경하며 매번 테스트를 돌려야 하므로 코드를 여기저기 옮길 일이 많아진다.   
리팩터링은 루빅 큐브 맞추기와 비슷하다. 

- 큰 목표를 세운다 
- 목표를 이루기 위해 자잘한 단계를 수없이 거친다
- 각 단게를 거쳐야 다음 단계가 가능하다
- 위의 과정들을 반복하며 비로소 완성할 수 있다


저자는 모든 테스트를 통과하도록 코드를 점진적으로 개선해 나가고 있음을 알 수 있다    


#### 소프트웨어의 품질을 높이는 법
- 소프트웨어 설계는 분할만 잘해도 품질이 크게 높아진다.
- 적절한 장소를 만들어 코드만 분리해도 설계가 좋아진다.   
- 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워진다.

#### 프로그래머 정신
- 단순히 돌아가는 코드에 만족하는 프로그래머는 전문가 정신이 부족하다
- 나쁜 코드는 썩어 문드러져 결국 팀의 발목을 잡게 된다  

**코드가 썩으면?**  
- 모듈은 서로 서로 얽히고 설켜 뒤엉키고 의존성이 생긴다 
- 이를 개선하기 위해서는 상당한 시간과 인내심이 필요하다 

**처음부터 깨끗한 코드를 유지하는 것은 쉬우므로 직전에 만든 코드를 당장 정리하는 것이 가장 좋은 방법이다**

> 결론  
코드는 언제나 최대한 깔끔하고 단순하게 정리하며, 절대로 썩어가게 방치하면 안된다
